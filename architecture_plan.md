# Architecture Plan for macOS Motivational‚ÄêImages Widget

This document describes the end-to-end changes to evolve our existing ‚Äúrandom-image‚Äù widget into a category-aware, feedback-driven widget using Supabase as our backend.

---

## üì¶ Current State

- Widget pulls a truly random image URL from the `motivational-images` Storage bucket.
- No notion of categories or user feedback.
- Single table `images(id, image_name, image_url, ‚Ä¶)` drives all widget behavior.

---

## üöÄ Phase One: Add Categories & Filtered Random-Pick

### 1. Database Schema

We‚Äôve already added two new tables:

```sql
-- 1Ô∏è‚É£ categories catalog
CREATE TABLE public.categories (
  id          BIGINT       GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  name        TEXT         NOT NULL,               -- human-readable name
  description TEXT,
  created_at  TIMESTAMPTZ  NOT NULL DEFAULT now()
);

-- 2Ô∏è‚É£ join table for tagging images
CREATE TABLE public.image_categories (
  image_id    BIGINT       NOT NULL
    REFERENCES public.images(id)     ON DELETE CASCADE,
  category_id BIGINT       NOT NULL
    REFERENCES public.categories(id) ON DELETE CASCADE,
  PRIMARY KEY (image_id, category_id)
);
```

### 2. Backend API

Expose two new endpoints (via Supabase Edge Functions or PostgREST):

1. **List all categories**  
   ```
   GET /categories
   ‚Üí [{ id, name, description }, ‚Ä¶]
   ```

2. **Fetch a random image by category set**  
   ```
   GET /images/random?categories[]=1&categories[]=2 -- Example using category IDs
   ‚Üí { id, image_url, likes_count, dislikes_count }
   ```
   - If no `categories[]` query params ‚Üí fallback to fully random.

#### Suggested SQL for random-pick:
```sql
SELECT i.id, i.image_url, i.likes_count, i.dislikes_count
  FROM public.images i
  JOIN public.image_categories ic ON ic.image_id = i.id
 WHERE ic.category_id = ANY($1::bigint[])
ORDER BY random()
   LIMIT 1;
```

### 3. Widget UI Changes

1. **Fetch categories** at launch (or cache in App Group):
   ```swift
   let categories = try await supabase
     .from("categories")
     .select()
     .order(column: "name")
     .execute()
   ```

2. **Category Picker**  
   - In your host app‚Äôs settings screen (or in Intent UI on macOS 14+), display a list of checkboxes. Each checkbox should display the category's `name` and be associated with its `id`.
   - Persist the selected category `id`s (e.g., as an array of strings, like `["1", "2"]`) to `UserDefaults(suiteName:)` under the App Group, using a key like `"selectedCategoryIDs"`.

3. **TimelineProvider**  
   - Read `selectedCategoryIDs: [String]` (or your chosen key) from App Group defaults.
   - Call your `/images/random` endpoint with that array.  
   - Fallback to no-args fetch if the array is empty.

4. **Example SwiftUI filter logic**:
   ```swift
   let selectedCategoryIDs = UserDefaults(suiteName: groupID)?
     .stringArray(forKey: "selectedCategoryIDs") ?? [] // Ensure key matches persistence

   // ... then use selectedCategoryIDs to build the URL query
   // Example: + (selectedCategoryIDs.isEmpty ? "" : "?"+selectedCategoryIDs.map{"categories[]=\($0)"}.joined(separator: "&"))

   let url = URL(string: "https://vwvhpnxnumfvxasbopcq.supabase.co/functions/v1/images-random"
     + (selected.isEmpty ? "" : "?"+selected.map{"categories[]=\($0)"}.joined(separator: "&"))
   )!
   ```

---

## üëç Phase Two: Add Thumbs-Up/Thumbs-Down Feedback

### 1. Database Schema

We keep global counters on `images`:
```sql
ALTER TABLE public.images
  ADD COLUMN likes_count    INTEGER NOT NULL DEFAULT 0,
  ADD COLUMN dislikes_count INTEGER NOT NULL DEFAULT 0;
```

### 2. App Intent Definition (macOS 14+ interactive widgets)

In your `.intentdefinition` file:
```xml
<Intent name="ImageFeedbackIntent" displayName="Send Image Feedback">
  <Parameter name="imageID" type="String" displayName="Image ID" />
  <Parameter name="liked"   type="Boolean" displayName="Thumbs Up?"  />
  <Result type="Boolean" name="success" />
</Intent>
```

### 3. Intent Handler

Implement `ImageFeedbackIntentHandling` in your App Intent extension:
```swift
func handle(intent: ImageFeedbackIntent, completion: @escaping (ImageFeedbackIntentResponse) -> Void) {
  let likedValue = intent.liked?.boolValue ?? false
  Task {
    let rpc = supabase
      .from("increment_feedback")
      .rpc(params: ["image_id": Int(intent.imageID!)!, "liked": likedValue])
    let response = try await rpc.execute()
    completion(.init(code: .success, userActivity: nil))
  }
}
```
> You can implement an RPC function `increment_feedback(image_id bigint, liked boolean)` in Postgres to `UPDATE images SET likes_count = likes_count + (liked::int), dislikes_count = dislikes_count + ((NOT liked)::int) WHERE id = image_id;`.

### 4. Widget UI ‚Äì Feedback Buttons

In your SwiftUI widget view:
```swift
HStack {
  Button(intent: ImageFeedbackIntent(imageID: "\(entry.id)", liked: true)) {
    Image(systemName: "hand.thumbsup")
  }
  Spacer()
  Button(intent: ImageFeedbackIntent(imageID: "\(entry.id)", liked: false)) {
    Image(systemName: "hand.thumbsdown")
  }
}
.padding([.top, .horizontal])
```
- Buttons fire the intent inline (no app-launch).  
- After the intent runs, you can call `WidgetCenter.shared.reloadAllTimelines()` to refresh scores/ordering.

---

## üèõÔ∏è Architectural Review &amp; Commentary

This architecture plan provides a solid foundation for enhancing the Motivational Images Widget. The phased approach is practical, and the technical details for database, API, and UI changes are well-considered.

**Key Strengths:**

*   **Clear Phased Rollout:** Separating category implementation (Phase One) from feedback mechanisms (Phase Two) allows for iterative development and testing.
*   **Modern Backend Choice:** Leveraging Supabase for database, authentication (implicitly, for future user-specific features), and serverless functions (Edge Functions for APIs, RPC for atomic DB operations) is a scalable and developer-friendly approach.
*   **Platform Awareness:** The plan correctly identifies the need for interactive widget capabilities (macOS 14+) and provides fallbacks/alternative approaches for older macOS versions.
*   **Data Sharing:** The use of App Groups for sharing data (like selected categories) between the main app and the widget extension is the correct mechanism on macOS.

**Alignment with Current Project Setup:**

*   **Supabase Client:** The project's `MotiVate/core/SupabaseClient.swift` is already configured with the correct Supabase project URL (`https://vwvhpnxnumfvxasbopcq.supabase.co`) and public anonymous key. This means direct Supabase SDK calls from Swift (e.g., for fetching categories or invoking RPCs) will work as intended.
*   **API Endpoint Update:** The example URL for the custom `/images/random` endpoint in Phase One (Widget UI Changes, item 4) has been updated from a placeholder to the correct Supabase Edge Function URL: `https://vwvhpnxnumfvxasbopcq.supabase.co/functions/v1/images-random`. This assumes an Edge Function named `images-random` will be created.

**Important Implementation Notes (Reiteration &amp; Emphasis):**

*   **App Group Identifier:** Ensure the `groupID` string used in `UserDefaults(suiteName: groupID)` is consistently defined and configured in the `.entitlements` files for both the main application target and the widget extension target.
*   **Intent Definition File:** The `ImageFeedbackIntent.intentdefinition` file (Phase Two) must be created and correctly added to your main app target. It can also be part of a shared framework if you structure your project that way.
*   **Supabase RPC Function:** The PostgreSQL function `increment_feedback(image_id bigint, liked boolean)` (Phase Two) needs to be created within your Supabase project's database schema.
*   **SQL for Random Pick:** The SQL query for `GET /images/random` is suitable for an Edge Function. Ensure appropriate database indexing on `image_categories.category_id` and `images.id` for performance.
*   **Error Handling &amp; UX:** While mentioned under "Next Steps," robust error handling for API calls (category fetch, image fetch, feedback submission) and clear user feedback (e.g., loading states, error messages/placeholders) should be integrated throughout development.
*   **Security for Edge Functions/RPCs:** Review Row Level Security (RLS) policies on your Supabase tables. Ensure that any Edge Functions or RPCs are designed with appropriate authorization if they perform sensitive operations or modify data. The `increment_feedback` RPC, for example, should be callable by users but protected against abuse if possible (e.g., rate limiting, or ensuring `image_id` is valid).

This commentary aims to reinforce the plan's strengths and highlight key areas for attention during implementation.
## üìà Next Steps & Considerations

1. **Caching & Offline**  
   - Store last-fetched image in App Group container to show if network is unavailable.  
2. **Error Handling**  
   - Provide a placeholder image on fetch failures.  
   - Debounce multiple feedback taps within a short window.  
3. **Analytics & Roll-ups**  
   - If you need time-series analytics later, consider a lightweight `image_feedback_events` table alongside global counters.  
4. **Versioning & Compatibility**  
   - For macOS ‚â§ Ventura, degrade gracefully: use `Link(destination:)` to open the main app for feedback instead of inline buttons.
