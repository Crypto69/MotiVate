# Architecture Plan for macOS Motivational‚ÄêImages Widget

This document describes the end-to-end changes to evolve our existing ‚Äúrandom-image‚Äù widget into a category-aware, feedback-driven widget using Supabase as our backend.

---

## üì¶ Current State

- Widget pulls a truly random image URL from the `motivational-images` Storage bucket.
- No notion of categories or user feedback.
- Single table `images(id, image_name, image_url, ‚Ä¶)` drives all widget behavior.

---

## üöÄ Phase One: Add Categories & Filtered Random-Pick

### 1. Database Schema

We‚Äôve already added two new tables:

```sql
-- 1Ô∏è‚É£ categories catalog
CREATE TABLE public.categories (
  id          BIGINT       GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  name        TEXT         NOT NULL,               -- human-readable name
  description TEXT,
  created_at  TIMESTAMPTZ  NOT NULL DEFAULT now()
);

-- 2Ô∏è‚É£ join table for tagging images
CREATE TABLE public.image_categories (
  image_id    BIGINT       NOT NULL
    REFERENCES public.images(id)     ON DELETE CASCADE,
  category_id BIGINT       NOT NULL
    REFERENCES public.categories(id) ON DELETE CASCADE,
  PRIMARY KEY (image_id, category_id)
);
```

### 2. Backend API
 
We will expose functionality through a combination of PostgREST for direct table access and a PostgreSQL Remote Procedure Call (RPC) for custom logic.
 
1. **List all categories** (via PostgREST)
   ```
   GET /rest/v1/categories
   ‚Üí [{ id, name, description }, ‚Ä¶]
   ```
   *(This assumes RLS is set up appropriately for the `categories` table.)*
 
2. **Fetch a random image by category set** (via RPC)
   - This will be handled by calling the `get_random_image(category_ids bigint[])` PostgreSQL function directly from the client using Supabase's RPC mechanism.
   - **Input:** An array of category IDs (or `NULL` for fully random).
   - **Output:** `{ id, image_url, likes_count, dislikes_count }`
   - The SQL for this function is defined as:
     ```sql
     CREATE OR REPLACE FUNCTION get_random_image(category_ids bigint[] DEFAULT NULL)
     RETURNS TABLE (
         id bigint,
         image_url text,
         likes_count integer,
         dislikes_count integer
     )
     -- ... (rest of function definition)
     ```
 
   *(The `get_random_image` function has already been implemented.)*

### 3. Widget UI Changes

1. **Fetch categories** at launch (or cache in App Group):
   ```swift
   let categories = try await supabase
     .from("categories")
     .select()
     .order(column: "name")
     .execute()
   ```

2. **Category Picker**  
   - In your host app‚Äôs settings screen (or in Intent UI on macOS 14+), display a list of checkboxes. Each checkbox should display the category's `name` and be associated with its `id`.
   - Persist the selected category `id`s (e.g., as an array of strings, like `["1", "2"]`) to `UserDefaults(suiteName:)` under the App Group, using a key like `"selectedCategoryIDs"`.

3. **TimelineProvider**
   - Read `selectedCategoryIDs: [String]` (or your chosen key) from App Group defaults.
   - Convert string IDs to `Int` or `Int64` as appropriate for the RPC call.
   - Call the `get_random_image` PostgreSQL function via RPC, passing the selected category IDs (or `nil` if empty).
 
4. **Example SwiftUI RPC call logic**:
   ```swift
   // Assuming 'supabase' is your configured SupabaseClient instance
   // and 'ImageResponse' is a Decodable struct matching the function's output
   
   struct ImageResponse: Decodable, Identifiable {
       let id: Int64 // Or Int, depending on your DB schema
       let image_url: String
       let likes_count: Int
       let dislikes_count: Int
   }
   
   let selectedCategoryIDsStrings = UserDefaults(suiteName: groupID)?
     .stringArray(forKey: "selectedCategoryIDs") ?? []
   
   let categoryIDsForRPC: [Int64]? = selectedCategoryIDsStrings.isEmpty ? 
       nil : 
       selectedCategoryIDsStrings.compactMap { Int64($0) }
   
   // If compactMap results in an empty array but selectedCategoryIDsStrings was not empty,
   // it means there were non-integer strings. Handle this case as needed.
   // For simplicity here, we assume valid integer strings or an empty initial array.
   
   do {
       let imageResponse: ImageResponse = try await supabase
           .rpc("get_random_image", params: ["category_ids": categoryIDsForRPC]) // Pass nil if no categories
           .select() // Required to get the row data
           .single() // Expecting a single row
           .execute()
           .value
       // Use imageResponse
   } catch {
       // Handle error
       print("Error fetching random image: \(error)")
   }
   ```

---

## üëç Phase Two: Add Thumbs-Up/Thumbs-Down Feedback

### 1. Database Schema

We keep global counters on `images`:
```sql
ALTER TABLE public.images
  ADD COLUMN likes_count    INTEGER NOT NULL DEFAULT 0,
  ADD COLUMN dislikes_count INTEGER NOT NULL DEFAULT 0;
```

### 2. App Intent Definition (macOS 14+ interactive widgets)

In your `.intentdefinition` file:
```xml
<Intent name="ImageFeedbackIntent" displayName="Send Image Feedback">
  <Parameter name="imageID" type="String" displayName="Image ID" />
  <Parameter name="liked"   type="Boolean" displayName="Thumbs Up?"  />
  <Result type="Boolean" name="success" />
</Intent>
```

### 3. Intent Handler

Implement `ImageFeedbackIntentHandling` in your App Intent extension:
```swift
func handle(intent: ImageFeedbackIntent, completion: @escaping (ImageFeedbackIntentResponse) -> Void) {
  let likedValue = intent.liked?.boolValue ?? false
  Task {
    let rpc = supabase
      .from("increment_feedback")
      .rpc(params: ["image_id": Int(intent.imageID!)!, "liked": likedValue])
    let response = try await rpc.execute()
    completion(.init(code: .success, userActivity: nil))
  }
}
```
> You can implement an RPC function `increment_feedback(image_id bigint, liked boolean)` in Postgres to `UPDATE images SET likes_count = likes_count + (liked::int), dislikes_count = dislikes_count + ((NOT liked)::int) WHERE id = image_id;`.

### 4. Widget UI ‚Äì Feedback Buttons

In your SwiftUI widget view:
```swift
HStack {
  Button(intent: ImageFeedbackIntent(imageID: "\(entry.id)", liked: true)) {
    Image(systemName: "hand.thumbsup")
  }
  Spacer()
  Button(intent: ImageFeedbackIntent(imageID: "\(entry.id)", liked: false)) {
    Image(systemName: "hand.thumbsdown")
  }
}
.padding([.top, .horizontal])
```
- Buttons fire the intent inline (no app-launch).  
- After the intent runs, you can call `WidgetCenter.shared.reloadAllTimelines()` to refresh scores/ordering.

---

## üèõÔ∏è Architectural Review & Commentary

This architecture plan provides a solid foundation for enhancing the Motivational Images Widget. The phased approach is practical, and the technical details for database, API, and UI changes are well-considered.

**Key Strengths:**

*   **Clear Phased Rollout:** Separating category implementation (Phase One) from feedback mechanisms (Phase Two) allows for iterative development and testing.
*   **Modern Backend Choice:** Leveraging Supabase for database, authentication (implicitly, for future user-specific features), and PostgreSQL RPC functions for custom database logic is a scalable and developer-friendly approach.
*   **Platform Awareness:** The plan correctly identifies the need for interactive widget capabilities (macOS 14+) and provides fallbacks/alternative approaches for older macOS versions.
*   **Data Sharing:** The use of App Groups for sharing data (like selected categories) between the main app and the widget extension is the correct mechanism on macOS.

**Alignment with Current Project Setup:**

*   **Supabase Client:** The project's `MotiVate/core/SupabaseClient.swift` is already configured with the correct Supabase project URL (`https://vwvhpnxnumfvxasbopcq.supabase.co`) and public anonymous key. This means direct Supabase SDK calls from Swift (e.g., for fetching categories or invoking RPCs like `get_random_image` and `increment_feedback`) will work as intended.
*   **API Approach:** The `/images/random` functionality will be accessed by directly calling the `get_random_image` PostgreSQL function via RPC from the Swift client, instead of through a Supabase Edge Function. This simplifies the backend architecture for this specific endpoint.

**Important Implementation Notes (Reiteration & Emphasis):**

*   **App Group Identifier:** Ensure the `groupID` string used in `UserDefaults(suiteName: groupID)` is consistently defined and configured in the `.entitlements` files for both the main application target and the widget extension target.
*   **Intent Definition File:** The `ImageFeedbackIntent.intentdefinition` file (Phase Two) must be created and correctly added to your main app target. It can also be part of a shared framework if you structure your project that way.
*   **Supabase RPC Functions:** The PostgreSQL functions `get_random_image(category_ids bigint[])` (Phase One) and `increment_feedback(image_id bigint, liked boolean)` (Phase Two) need to be created (or confirmed to exist) within your Supabase project's database schema and be callable via RPC.
*   **Database Indexing:** Ensure appropriate database indexing on `image_categories.category_id` and `images.id` for performance of the `get_random_image` function.
*   **Error Handling & UX:** While mentioned under "Next Steps," robust error handling for API calls (category fetch, image fetch via RPC, feedback submission via RPC) and clear user feedback (e.g., loading states, error messages/placeholders) should be integrated throughout development.
*   **Security for RPCs:** Review Row Level Security (RLS) policies on your Supabase tables. Ensure that RPCs are designed with appropriate authorization. The `get_random_image` and `increment_feedback` RPCs should be callable by `anon` users as per previous discussions, but ensure the underlying tables (`images`, `categories`, `image_categories`) have appropriate RLS for read access if needed, and that the functions themselves don't inadvertently expose or modify data they shouldn't. The `SECURITY DEFINER` clause in the functions means they run with the permissions of the user who defined them, so ensure this definer role has the minimum necessary privileges.

This commentary aims to reinforce the plan's strengths and highlight key areas for attention during implementation.
## üìà Next Steps & Considerations

1. **Caching & Offline**  
   - Store last-fetched image in App Group container to show if network is unavailable.  
2. **Error Handling**  
   - Provide a placeholder image on fetch failures.  
   - Debounce multiple feedback taps within a short window.  
3. **Analytics & Roll-ups**  
   - If you need time-series analytics later, consider a lightweight `image_feedback_events` table alongside global counters.  
4. **Versioning & Compatibility**  
   - For macOS ‚â§ Ventura, degrade gracefully: use `Link(destination:)` to open the main app for feedback instead of inline buttons.
